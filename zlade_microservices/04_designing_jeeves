-----------------------------------------------------------------------
| CHAPTER 4 - DESIGNING JEEVES                                        |
-----------------------------------------------------------------------

- Designing Jeeves

    - A natural way to build a microservices application is to start with a monolithic version, then split
        it into microservices that make the most sense.


    - In this chapter we'll look at 2 things:

        1. Presentation of our application and its user stories
        2. How Jeeves can be built as a monolithic application



- The Jeeves Bot

    - Jeeves will connect to Slack, which is used to send text messages in channels, similar to the old IRC
        service.  It will be our personal assistant.

    - Once Jeeves is connected to a Slack workspace, a user can send the bot messages and receive replies.
        Users can also visit the web page and register for any 3rd-party services they might need to connect
        to thanks to the OAuth2 standard.

    - We'll be using Strava as an example of a 3rd party site we'll connect to.

    - The OAuth2 standard is based on authorizing a 3rd party application to call a service with an access
        token that is unique to the user of the service.  The token is generated by the service and usually
        has limited scope in what calls can be performed.



- User Stories

    - Here are the initial user stories:

        1. As a Slack workspace user, I can send messages to a bot and get updates about the weather 
             without leaving Slack.

        2. As a Slack workspace user, I expect the bot to remember facts that I have told it about myself, 
             such as my location.

        3. As a Slack workspace user, I can visit the bot's control panel and authenticate third-party
             services, such as GitHub and Strava.

        4. As an admin of the bot, I can get statistics regarding the bot's usage.

        5. As an admin of the bot, I can disable or change the configuration of various features.

        6. As a user, I can create an account on a third-party site that the bot knows about, and then use 
             the bot to perform tasks there.


    - The components arising initially from these stories:

        - The app needs to store the contents of some types of messages it receives.  These may be stored
            against a specific Slack identity.

        - A user should be able to navigate to a web interface for third-party site authentication.

        - The app will authenticate web users with a password or a URL with a provided token.

        - The app should be able to perform periodic scheduled tasks to alert the user if a condition is 
            true, such as for bad weather.



- Monolithic Design

    - We'll need to retrieve data from Slack into our application.  All Slack events are sent to the URL
        that the app developer configures.

    - We'll also need a small interface so that uses can adjust their settings outside Slack, like
        controlling 3rd party authentication tokens and updating permissions.  We'll need a small database
        to store all of these things in.

    - Lastly, we'll need some code to actually perform the actions the bot should do.



- Models and Views

    - The database tables for Jeeves will be:

        User = contains information about each user, including their credentials
        Service = List of available services the bot can provide
        Log = a log of bot activity


    - The User table:

        class User(db.Model):
            id
            name
            email
            slack_id
            password
            config (json)
            is_active
            is_admin

            def json(self):
                return {"id": self.id, "email": self.email, "config": self.config}


    - We create a separate DAL class:

        class UserDAL:
            def __init__(self, db_session)
                self.db_session = db_session

            def create_user(new_user)
            def get_all_users(self)
            def get_user(self, user_id)


    - Create the views:

        @app.get('/users')
        def get_all_users():
            with user_dal as ud:
                return ud.get_all_users()



- Slack Workspaces

    - Slack allows people to connect apps to a workspace.  If you are an administor of a Slack instance,
        you can create a new bot user.

    - When you create a new user, a token will be generated, which you should copy into your application's
        settings so that it can authorize to Slack when sending messages.

    - Also when creating the bot, you can subscribe to be notified of events (ie when a user adds a 
        reaction or creates a file) at a URL you specify.  An HTTP POST will be sent to that URL each time
        an event occurs.

    - Applications can subscribe to receive events the bot user has access to as well.  We'll subscribe
        to 'app_mention' events, which occur when someone mentions our app or bot.


    - We'll need to add the following permissions for our bot:

        app_mentions:read           # View messages that directly mention @jeeves

        chat:write                  # Send messages as @jeeves

        chat:write:customize        # Send messages as @jeeves with custom username and avatar

        chat:write:public           # Send messages to channels @jeeves isn't a member of

        files:read                  # View files shared in channels and conversations @jeeves has been
                                    #   added to

        incoming-webhook            # Post messages to specific channels in Slack



- Incoming Events

    - This is the JSON sent for an event in which someone asked for the weather in London:

        {
            "event": {
                "client_msg_id": "79cd47ec-4586-4677-a50d-4db58bdfcd4b",
                "type": "app_mention",
                "text": "<@U01HYK05BLM>\u00a0weather in London, UK",
                "user": "U136F44A0",
                "ts": "1611254457.003600",
                "team": "T136F4492",
                "blocks": [
                    {
                        "type": "rich_text",
                        "block_id": "pqx",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "user",
                                        "user_id": "U01HYK05BLM"
                                    },
                                    {
                                        "type": "text",
                                        "text": " weather in London, UK"
                                    }
                                ]
                            }
                        ]
                    }
                ],
            â€¦ 
        }



- Taking Actions

    - We'll parse the event, and look for keywords that tell us which action to take.  For now, we'll
        start with a simple mapping for the actions we can take:

            ACTION_MAP = {
                "help": show_help_text,
                "weather": fetch_weather,
                "config": user_config,
            }

            def process_message(message, metadata):
                """Decide on an action for a chat message.
                Arguments:
                    message (str): The body of the chat message
                    metadata (dict): Data about who sent the message,
                          the time and channel.
                """
                reply = None
                for test, action in ACTION_MAP.items():
                    if message.startswith(test):
                        reply = action(message.lstrip(test), metadata)
                        break
                if reply:
                    post_to_slack(reply, metadata)



- OAuth Tokens

    - OAuth2 allows us to make an authenticated request to someone else's site.  We could request read-only
        access to someone's Google Calendar, permission to post issues on GitHub, or the ability to read
        information about recorded exercises in a fitness application.

    - We can do all this without asking for someone's password for a different site, which no one should
        ever do.

    - For our example, we will connect to Slack to allow the people using our bot to log in and update
        information about themselves.  We can also use this to fetch information about them, such as
        details of their Slack profile, if they allow us to.

    - We will present people visiting a web page with a button they can use to log into the site using
        Slack, which will send them to Slack to authorize our application.  If they agree, then our
        application is given a code, which we can then use to request an access token.

    - That access token will let us connect Slack and verify that the token is still valid, and let us
        ask for the information the person has allowed us to view or change.

    - We'll need HTTPS enabled and a valid site certificate for this.  The easiest way to do that is to
        use a proxy and a 'Let's Encrypt' certificate.


    - This is how we'll log users in:

            # slack_oauth2.py
            ------------------------------------------------------
            import os
            import requests
            from flask import Flask, request, render_template

            @app.route("/")
            def welcome_page():
                client_id = os.environ["SLACK_CLIENT_ID"]
                return render_template("welcome.html", client_id=client_id)

            @app.route("/slack/callback")
            def oauth2_slack_callback():
                code = request.args["code"]
                client_id = os.environ["SLACK_CLIENT_ID"]
                client_secret = os.environ["SLACK_CLIENT_SECRET"]

                access_url = f"https://slack.com/api/
                    oauth.v2.access?client_id={client_id}&client_secret={client_secret}&code={code}"

                async with aiohttp.ClientSession() as session:
                    async with session.get(access_url) as resp:

                response = requests.get(access_url)
                access_data = response.json()
                print(access_data)
                return render_template("logged_in.html")



- Authentication and Authorization

    - We will know users by their 9-character Slack user identifier (ie 'U01HYK05BLM').  We need to figure
        out how to connect that with the web interface.

    - The easiest way to is to get a sign-in link from the bot.  If a users sends Jeeves a message asking
        to log in, Jeeves can reply with a URL.  Once visited, that URL will let the user set a password
        and use all the web features.


    - Our welcome page will now require a login:

        @app.route('/')
        @login_required
        def welcome_page():
            return render_template('welcome.html')


    - If a user is not logged in, they will be redirected to the welcome page:

        @app.route('/slack_login')
        def slack_login():
            client_id = os.environ["SLACK_CLIENT_ID"]
            return render_template("login.html", client_id=client_id)

        @app.error_handler(Unauthorized)
        def redirect_to_login():
            return redirect(url_for('slack_login'))


    - Putting all of this together in a working example:

        import os
        import requests
        import secrets

        from flask import Flask, request, render_template, redirect, url_for
        from flask_auth import AuthManager, login_required, login_user, AuthUser, Unauthorized

        app.secret_key = secrets.token_urlsafe(16)

        @app.route("/")
        @login_required
        def welcome_page():
            return render_template("welcome.html")

        @app.route("/slack_login")
        def slack_login():
            client_id = os.environ["SLACK_CLIENT_ID"]
            return render_template("login.html", client_id=client_id)

        @app.errorhandler(Unauthorized)
        def redirect_to_login(_):
            return redirect(url_for("slack_login"))

        @app.route("/slack/callback")
        def oauth2_slack_callback():
            code = request.args["code"]
            client_id = os.environ["SLACK_CLIENT_ID"]
            client_secret = os.environ["SLACK_CLIENT_SECRET"]

            access_url = f"https://slack.com/api/
                oauth.v2.access?client_id={client_id}&client_secret={client_secret}&code={code}"

            response = requests.get(access_url)
            access_data = response.json()

            if access_data["ok"] is True:
                authed_user = access_data["authed_user"]["id"]
                login_user(AuthUser(authed_user))
                return redirect(url_for("welcome_page")

            return redirect(url_for("slack_login"))


    - In this case, we are not storing any passwords directly.


    - We'll now have the 'current_user' variable set in the application context.  We'll need to add some
        authorization.  For instance, we can allow a user to change their data, but not other people's
        data.



- Background Tasks

    - We have several features that would be useful to run as scheduled tasks:

        - Our weather action could check for weather alerts in a user's area and send a message to them

        - A calendar action could report on your scheduled meetings at the start of the working day

        - A monthly report of the actions taken could be produced and emailed to the bot admin


    - These tasks need to run outside the request/response cycle.  Celery is a popular way to run
        background tasks in Python web apps.  It is a distributed task queue that can work in a standalone
        process.

    - To run these pieces of work, an intermediate called a 'message broker' is in charge of passing
        messages back and forth between the application and Celery.  If the app wants Celery to run
        something, it will add a message in the broker, and Celery will poll it and do the job.

    - Celery works out of the box with AMQP services such as RabbitMQ, Redis, and AWS SQS.  AMQP provides
        a standard set of techniques for routing and delivering messages in a reliable way.  We'll be
        using RabbitMQ, which will ensure messages reach their destination.

    - The component that executes the job is called a worker, and Celery provides a class to start one.


    - Here, we get all the users with locations set in their user accounts:

        def get_users_with_locations(self):
            query = select(User).where(User.location is not None)
            return self.db_session.execute(query)


    - Now, we can set up a worker to do the task:

        # weather_worker.py
        ---------------------------
        from celery import Celery
        from database import user_dal

        celery_app = Celery('tasks', broker='amqp://localhost')

        def fetch_weather(location):
            return 'This is where we would call the weather service.'

        def post_to_slack(message, options):
            print(f'This is where we would post {message}.')

        def weather_alerts():
            ud = user_dal()
            query_results = ud.get_users_with_locations()
            for user in query_results:
                user = user[0]
                weather_message = fetch_weather(user.location)
                username = user.slack_id
                if not username.startswith('@'):
                    username = '@' + username
                post_to_slack(weather_message, {'channel': username})

        @celery_app.task
        def do_weather_alerts():
            weather_alerts()

        @celery_app.on_after_configure.connect
        def setup_periodic_tasks(sender, **kwargs):
            sender.add_periodic_task(10.0, do_weather_alerts, name='fetch the weather', expires=30)


    - Celery will need RabbitMQ running in order to work.  We run the Celery background worker, which 
        will wait for messages to arrive asking it to do work.  We will also run the scheduler (aka 'beat'),
        which will use the periodic tasks we set up.

        $ docker run -d -p 5672:5672 rabbitmq 
        $ celery -A background worker  --loglevel=INFO
        $ celery -A background beat --loglevel=INFO


    - In the previous setup, we set the job to run every 10 seconds, which is too frequent for a weather
        report.  Instead, we'll set it up to run once a week using cron-like settings:

            from celery.schedules import crontab

            @celery_app.on_after_configure.connect
            def setup_periodic_tasks(sender, **kwargs):
                sender.add_periodic_task(       
                    crontab(hour=7, minute=30, day_of_week='monday'),
                    do_weather_alerts, name="fetch the weather", expires=30
                )


    - Note that this is almost like a separate microservice, since both the RabbitMQ server and the Celery
        app can be deployed on another server.